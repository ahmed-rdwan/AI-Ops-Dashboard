# -*- coding: utf-8 -*-
"""Streamlit_IT_Dashboard

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ydubXG6k-MkJK2jDj8-cj-f6DP_8MMqy
"""

import streamlit as st
import pandas as pd
import numpy as np
import os
import json
import re
import datetime
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

# ==========================================
# 1. CORE LOGIC CLASSES (Ù†ÙØ³ Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ø³Ø§Ø¨Ù‚)
# ==========================================

# --- A. Duplicate Detector ---
class DuplicateTicketDetector:
    def __init__(self):
        self.vectorizer = TfidfVectorizer(stop_words='english')
        # Ø¨ÙŠØ§Ù†Ø§Øª ØªØ¬Ø±ÙŠØ¨ÙŠØ©
        if 'open_tickets' not in st.session_state:
            st.session_state.open_tickets = [
                {"id": 101, "text": "Internet connection is down wifi not working", "user": "Ali", "status": "Open"},
                {"id": 102, "text": "Printer in HR office is jamming paper", "user": "Mona", "status": "Open"},
                {"id": 103, "text": "Cannot login to ERP system wrong password", "user": "Hassan", "status": "Open"}
            ]
        self.GLOBAL_KEYWORDS = ['wifi', 'internet', 'network', 'server', 'power', 'system']

    def _is_global_issue(self, text):
        for kw in self.GLOBAL_KEYWORDS:
            if kw in text.lower(): return True
        return False

    def check_is_duplicate(self, new_text, new_user):
        if not st.session_state.open_tickets: return False, None, 0.0

        existing_texts = [t['text'] for t in st.session_state.open_tickets]
        corpus = existing_texts + [new_text]
        tfidf_matrix = self.vectorizer.fit_transform(corpus)

        sims = cosine_similarity(tfidf_matrix[-1], tfidf_matrix[:-1]).flatten()
        best_idx = np.argmax(sims)
        best_score = sims[best_idx]

        match_ticket = st.session_state.open_tickets[best_idx]

        if best_score > 0.5:
            if match_ticket['user'] == new_user:
                return True, match_ticket, best_score # Spam
            elif self._is_global_issue(new_text):
                return True, match_ticket, best_score # Global

        return False, None, best_score

    def add_ticket(self, text, user):
        new_id = st.session_state.open_tickets[-1]['id'] + 1 if st.session_state.open_tickets else 101
        st.session_state.open_tickets.append({"id": new_id, "text": text, "user": user, "status": "Open"})
        return new_id

# --- B. Task Dispatcher (Using CSV Persistence) ---
DATA_FILE = "technicians_state.csv"

class SmartDispatcher:
    def __init__(self):
        self.vectorizer = TfidfVectorizer(stop_words='english')
        self.df = self._load_state()

    def _load_state(self):
        if os.path.exists(DATA_FILE):
            df = pd.read_csv(DATA_FILE)
            # Ensure columns exist
            for col in ['keyword_weights', 'is_present', 'total_finished_tickets', 'solved_history_text']:
                if col not in df.columns:
                    df[col] = "{}" if 'weights' in col else (True if 'present' in col else (0 if 'total' in col else ""))
            df['solved_history_text'] = df['solved_history_text'].fillna("")
            return df
        else:
            # Default Data
            return pd.DataFrame([
                {"id": 1, "name": "Ahmed (Net)", "current_floor": 1, "active_tickets": 0, "is_present": True, "solved_history_text": "", "keyword_weights": "{}"},
                {"id": 2, "name": "Sara (Soft)", "current_floor": 3, "active_tickets": 0, "is_present": True, "solved_history_text": "", "keyword_weights": "{}"},
                {"id": 3, "name": "Khaled (Hard)", "current_floor": 5, "active_tickets": 0, "is_present": True, "solved_history_text": "", "keyword_weights": "{}"},
            ])

    def save(self):
        self.df.to_csv(DATA_FILE, index=False)

    def assign(self, text, floor):
        # Logic simplified for Streamlit demo
        # 1. Similarity
        try:
            corpus = self.df['solved_history_text'].tolist() + [text]
            matrix = self.vectorizer.fit_transform(corpus)
            sim_scores = cosine_similarity(matrix[-1], matrix[:-1]).flatten()
        except:
            sim_scores = np.zeros(len(self.df))

        # 2. Mastery (Mock logic for demo)
        mastery_scores = np.zeros(len(self.df))

        # 3. Proximity
        dists = abs(self.df['current_floor'] - floor)
        prox_scores = 1 - (dists / 10)

        # Final Score
        final = (sim_scores * 0.6) + (prox_scores * 0.4) - (self.df['active_tickets'] * 0.2)

        # Filter Absent
        final[self.df['is_present'] == False] = -99

        best_idx = np.argmax(final)
        winner = self.df.iloc[best_idx]

        # Update
        self.df.at[best_idx, 'active_tickets'] += 1
        self.save()
        return winner['name'], final[best_idx]

    def train(self, name, text):
        idx = self.df[self.df['name'] == name].index[0]
        # Simple update for demo
        curr = str(self.df.at[idx, 'solved_history_text'])
        self.df.at[idx, 'solved_history_text'] = curr + " " + text
        if self.df.at[idx, 'active_tickets'] > 0:
            self.df.at[idx, 'active_tickets'] -= 1
        self.save()

# --- C. Stock Forecaster ---
class StockAI:
    def generate_dummy_data(self, item_type):
        dates = pd.date_range(end=datetime.date.today(), periods=60)
        if item_type == 'Stable':
            qty = [100 - (i * 1.5) + np.random.normal(0, 2) for i in range(60)]
        else: # Volatile
            qty = [100 - (i * 0.5) + np.random.normal(0, 15) for i in range(60)]

        df = pd.DataFrame({'date': dates, 'quantity': qty})
        df['quantity'] = df['quantity'].clip(lower=0)
        return df

    def predict(self, df):
        df['day_num'] = np.arange(len(df))
        X = df[['day_num']]
        y = df['quantity']

        model = LinearRegression()
        model.fit(X, y)

        slope = model.coef_[0]
        intercept = model.intercept_

        if slope >= 0: return None, None, slope

        days_until_zero = -intercept / slope
        remaining = days_until_zero - df['day_num'].max()

        return int(remaining), model, slope

# ==========================================
# 2. STREAMLIT UI
# ==========================================

st.set_page_config(page_title="AI IT Operations", layout="wide")

st.title("ğŸ¤– Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø°ÙƒÙŠ (AI Ops)")

# Sidebar Navigation
page = st.sidebar.radio("Ø§Ø®ØªØ± Ø§Ù„Ù‚Ø³Ù…", ["ğŸ« ØªÙˆØ²ÙŠØ¹ Ø§Ù„ØªÙŠÙƒØªØ§Øª (Dispatcher)", "ğŸ“ˆ ØªÙ†Ø¨Ø¤ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† (Stock AI)"])

# --- PAGE 1: Dispatcher ---
if page == "ğŸ« ØªÙˆØ²ÙŠØ¹ Ø§Ù„ØªÙŠÙƒØªØ§Øª (Dispatcher)":
    st.header("ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ø°ÙƒÙŠ")

    col1, col2 = st.columns([2, 1])

    with col1:
        st.subheader("Ø¥Ø¶Ø§ÙØ© ØªÙŠÙƒØª Ø¬Ø¯ÙŠØ¯")
        ticket_text = st.text_area("ÙˆØµÙ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©", placeholder="Ù…Ø«Ø§Ù„: Ø§Ù„Ù†Øª ÙØ§ØµÙ„ ÙÙŠ Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø«Ø§Ù„Ø«")
        user_name = st.text_input("Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¸Ù", "User 1")
        floor = st.number_input("Ø§Ù„Ø¯ÙˆØ±", 1, 10, 1)

        if st.button("ğŸš€ ØªØ­Ù„ÙŠÙ„ ÙˆØ¥Ø³Ù†Ø§Ø¯"):
            # 1. Check Duplicate
            dup_sys = DuplicateTicketDetector()
            is_dup, match, score = dup_sys.check_is_duplicate(ticket_text, user_name)

            if is_dup:
                st.error(f"ğŸš« ØªÙ… Ø±ÙØ¶ Ø§Ù„ØªÙŠÙƒØª! (ØªÙƒØ±Ø§Ø± Ø¨Ù†Ø³Ø¨Ø© {score*100:.1f}%)")
                st.warning(f"Ù…Ø´Ø§Ø¨Ù‡ Ù„Ù„ØªÙŠÙƒØª Ø§Ù„Ù…ÙØªÙˆØ­: {match['text']} (Ø¨ÙˆØ§Ø³Ø·Ø©: {match['user']})")
            else:
                st.success("âœ… ØªÙŠÙƒØª Ø¬Ø¯ÙŠØ¯ ÙˆÙ…Ù‚Ø¨ÙˆÙ„.")

                # 2. Assign
                dispatcher = SmartDispatcher()
                winner_name, score = dispatcher.assign(ticket_text, floor)

                st.info(f"ğŸ‘¤ ØªÙ… Ø§Ù„Ø¥Ø³Ù†Ø§Ø¯ Ø¥Ù„Ù‰: **{winner_name}** (Score: {score:.2f})")
                st.caption("Ø§Ù„Ø³Ø¨Ø¨: Ø§Ù„Ø£Ù†Ø³Ø¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø¨Ø±Ø© ÙˆØ§Ù„Ù…ÙˆÙ‚Ø¹ ÙˆØ§Ù„Ø­Ù…Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ.")

                # Add to open list for simulation
                dup_sys.add_ticket(ticket_text, user_name)

    with col2:
        st.subheader("ğŸ‘¨â€ğŸ’» Ø­Ø§Ù„Ø© Ø§Ù„ÙØ±ÙŠÙ‚")
        dispatcher = SmartDispatcher()
        st.dataframe(dispatcher.df[['name', 'current_floor', 'active_tickets', 'is_present']])

        st.write("---")
        st.subheader("ğŸ“ ØªØ¯Ø±ÙŠØ¨ (Ø¥ØºÙ„Ø§Ù‚ ØªÙŠÙƒØª)")
        tech_to_train = st.selectbox("Ù…Ù† Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©ØŸ", dispatcher.df['name'])
        if st.button("ØªÙ… Ø§Ù„Ø­Ù„ âœ…"):
            dispatcher.train(tech_to_train, "sample problem solved")
            st.toast(f"ØªÙ… ØªØ­Ø¯ÙŠØ« Ø®Ø¨Ø±Ø© {tech_to_train}!")
            st.rerun()

# --- PAGE 2: Stock AI ---
elif page == "ğŸ“ˆ ØªÙ†Ø¨Ø¤ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† (Stock AI)":
    st.header("ØªØ­Ù„ÙŠÙ„ Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†")

    item_type = st.selectbox("Ø§Ø®ØªØ± Ø§Ù„ØµÙ†Ù Ù„Ù„ØªØ­Ù„ÙŠÙ„", ["Ø­Ø¨Ø± Ø·Ø§Ø¨Ø¹Ø© (Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ù…Ù†ØªØ¸Ù…)", "ÙˆØ±Ù‚ A4 (Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø¹Ø´ÙˆØ§Ø¦ÙŠ)"])

    stock_ai = StockAI()
    # Generate Mock Data based on selection
    if "Ø­Ø¨Ø±" in item_type:
        df = stock_ai.generate_dummy_data('Stable')
    else:
        df = stock_ai.generate_dummy_data('Random')

    # Show Chart
    st.line_chart(df.set_index('date')['quantity'])

    # Analyze
    days_left, model, slope = stock_ai.predict(df)

    col1, col2, col3 = st.columns(3)
    col1.metric("Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©", f"{int(df['quantity'].iloc[-1])}")
    col2.metric("Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ", f"{abs(slope):.2f} / ÙŠÙˆÙ…")

    if days_left is not None:
        if days_left < 7:
            col3.metric("Ø³ÙŠÙ†ÙØ° Ø®Ù„Ø§Ù„", f"{days_left} ÙŠÙˆÙ…", delta="-Ø®Ø·Ø±", delta_color="inverse")
            st.error(f"ğŸ”´ ØªØ­Ø°ÙŠØ±: Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø³ÙŠÙ†ÙØ° Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¬Ø¯Ø§Ù‹ (Ø®Ù„Ø§Ù„ {days_left} Ø£ÙŠØ§Ù…)!")
        else:
            col3.metric("Ø³ÙŠÙ†ÙØ° Ø®Ù„Ø§Ù„", f"{days_left} ÙŠÙˆÙ…", delta="Ø¢Ù…Ù†")
            st.success("ğŸŸ¢ Ø§Ù„ÙˆØ¶Ø¹ Ø¢Ù…Ù†. Ø§Ù„Ù…Ø®Ø²ÙˆÙ† ÙŠÙƒÙÙŠ Ù„ÙØªØ±Ø© Ø¬ÙŠØ¯Ø©.")
    else:
        st.info("Ø§Ù„ÙƒÙ…ÙŠØ© ØªØ²ÙŠØ¯ Ø£Ùˆ Ù…Ø³ØªÙ‚Ø±Ø©.")

"""### 2. Ø¥Ø²Ø§ÙŠ ØªØ´ØºÙ„Ù‡ (ÙÙŠ 3 Ø®Ø·ÙˆØ§Øª)

1.  **Ø«Ø¨Ù‘Øª Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª** (Ù„Ùˆ Ù…Ø´ Ø¹Ù†Ø¯Ùƒ):
    ```bash
    pip install streamlit pandas numpy scikit-learn matplotlib
    ```
2.  **Ø§Ø­ÙØ¸ Ø§Ù„ÙƒÙˆØ¯** Ø§Ù„Ù„ÙŠ ÙÙˆÙ‚ ÙÙŠ Ù…Ù„Ù Ø§Ø³Ù…Ù‡ `app.py`.
3.  **Ø´ØºÙ‘Ù„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚** Ù…Ù† Ø§Ù„ØªÙŠØ±Ù…ÙŠÙ†Ø§Ù„ (CMD):
    ```bash
    streamlit run app.py
  ```
"""